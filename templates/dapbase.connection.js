// dapbase.connection.js - Auto-generated by 'dapbase init'
// Do not edit manually — regenerate with 'dapbase init'

// dapbase.connection.js
// Dapbase v0.0.2 — now with real file persistence

const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');

const DAPBASE_ROOT = __dirname;
let currentDb = null;
let currentDbPath = null;

const db = {
    // Switch to (or create) a database folder
    async use(databaseName) {
        if (!databaseName || typeof databaseName !== 'string') {
            throw new Error('Database name must be a non-empty string');
        }

        currentDb = databaseName.trim();
        currentDbPath = path.join(DAPBASE_ROOT, currentDb);

        if (!fs.existsSync(currentDbPath)) {
            fs.mkdirSync(currentDbPath, { recursive: true });
            console.log(`Created new database folder: ${currentDb}`);
        } else {
            console.log(`Using database: ${currentDb}`);
        }

        return db;
    },

    // Create a table → creates a .table JSON file
    async createTable(tableName, columns) {
        if (!currentDb) throw new Error('No database selected. Call db.use("name") first');
        if (!tableName || typeof tableName !== 'string') throw new Error('Table name required');
        if (!columns || typeof columns !== 'object') throw new Error('Columns definition required');

        const tablePath = path.join(currentDbPath, `${tableName}.table`);

        if (fs.existsSync(tablePath)) {
            throw new Error(`Table "${tableName}" already exists`);
        }

        const tableData = {
            name: tableName,
            createdAt: new Date().toISOString(),
            columns: columns,           // { id: 'int', name: 'text', ... }
            rows: []                           // start empty
        };
        // Auto-add id: 'uuid' if not present
        if (!columns.id) {
            tableData.columns.id = 'uuid';
        }

        fs.writeFileSync(tablePath, JSON.stringify(tableData, null, 2), 'utf-8');
        console.log(`Table "${tableName}" created with ${Object.keys(columns).length} columns`);
        return db;
    },

    // Insert data into table
    insert: async (tableName, rowData) => {
        if (!currentDb) throw new Error('No database selected');
        const tablePath = path.join(currentDbPath, `${tableName}.table`);
        if (!fs.existsSync(tablePath)) throw new Error(`Table ${tableName} not found`);

        const table = JSON.parse(fs.readFileSync(tablePath, 'utf-8'));
        // Auto-generate UUID if column is 'id' and value is missing
        if (table.columns.id === 'uuid' && !rowData.id) {
            rowData.id = uuidv4();
        }
        table.rows.push(rowData);
        fs.writeFileSync(tablePath, JSON.stringify(table, null, 2));
        console.log(`Inserted 1 row into ${tableName}`);
        console.log(`Inserted →`, rowData);
        return db;
    },

    // Select data from table with optional filtering
    select: async (tableName, options = {}) => {  // FIXED: Added options parameter
        if (!currentDbPath) throw new Error('No database selected');
        const tablePath = path.join(currentDbPath, `${tableName}.table`);
        if (!fs.existsSync(tablePath)) throw new Error(`Table not found`);

        const table = JSON.parse(fs.readFileSync(tablePath, 'utf-8'));
        let rows = table.rows;

        // Filter results if options.where is provided
        if (options && options.where) {
            rows = rows.filter(row =>
                Object.keys(options.where).every(key => row[key] === options.where[key])
            );
        }

        console.log(`\n${rows.length} row(s) from ${tableName}:`);
        console.table(rows);
        return rows;
    },

    // Update data in table
    update: async (tableName, updates, where) => {  // FIXED: Added async
        const tablePath = path.join(currentDbPath, `${tableName}.table`);
        const table = JSON.parse(fs.readFileSync(tablePath, 'utf-8'));
        let count = 0;

        table.rows = table.rows.map(row => {
            if (Object.keys(where).every(k => row[k] === where[k])) {
                count++;
                return { ...row, ...updates };
            }
            return row;
        });
        fs.writeFileSync(tablePath, JSON.stringify(table, null, 2));
        console.log(`Updated ${count} row(s)`);
        return db;
    },

    // Delete data from table
    delete: async (tableName, where) => {  // FIXED: Added async
        const tablePath = path.join(currentDbPath, `${tableName}.table`);
        const table = JSON.parse(fs.readFileSync(tablePath, 'utf-8'));
        const before = table.rows.length;

        table.rows = table.rows.filter(row =>
            !Object.keys(where).every(k => row[k] === where[k])
        );

        fs.writeFileSync(tablePath, JSON.stringify(table, null, 2));
        console.log(`Deleted ${before - table.rows.length} row(s)`);
        return db;
    },
};

module.exports = db;